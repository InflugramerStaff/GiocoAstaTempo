<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tabellone - Gioco d'Asta a Tempo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 8px;
        }
        .player-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        .player-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        .eliminated {
            background-color: #ffcccc;
            opacity: 0.7;
        }
        .round-results {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }
        .winner {
            font-weight: bold;
            color: green;
        }
        .game-info {
            display: flex;
            justify-content: space-between;
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .code-display {
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 4px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
        }
        .end-game-btn {
            background-color: #f44336;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 8px;
        }
        .end-game-btn:hover {
            background-color: #d32f2f;
        }
        @keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.4); }
    70% { box-shadow: 0 0 0 10px rgba(0, 123, 255, 0); }
    100% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0); }
}
.timer-active {
    animation: pulse 2s infinite;
}
    </style>
</head>
<body>
    <div class="header">
        <h1>Tabellone - Gioco d'Asta a Tempo</h1>
        <div>
            <button class="button" id="start-game-btn">Inizia Partita</button>
            <button class="button" id="next-round-btn" disabled>Prossimo Round</button>
        </div>
    </div>

    <div class="code-display" id="game-id-display">Codice: ...</div>

    <!-- Configurazione Partita -->
    <div style="margin-bottom: 20px; padding: 15px; background-color: #f8f8f8; border-radius: 8px;">
        <h3>Configurazione Partita</h3>
        <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <label for="expected-players" style="margin-right: 10px;">Numero di giocatori attesi:</label>
            <input type="number" id="expected-players" min="2" max="10" value="2" style="width: 60px; padding: 5px;">
            <button class="button" id="set-players-btn" style="margin-left: 10px;">Imposta</button>
        </div>
        <div id="players-status">
            Giocatori connessi: <span id="connected-players">0</span>/<span id="expected-players-count">2</span>
        </div>
    </div>

    <div class="game-info">
        <div>Round: <span id="current-round">0</span>/19</div>
        <div>Stato: <span id="game-status">In attesa di giocatori</span></div>
    </div>

    <!-- Subito dopo <div class="game-info"> e prima della tabella dei giocatori -->
<div class="round-timer-container" style="text-align: center; margin: 20px 0; padding: 15px; background-color: #f0f7ff; border-radius: 8px; border: 2px solid #007bff;">
    <h2>Timer Round</h2>
    <div id="round-timer" style="font-family: monospace; font-size: 48px; font-weight: bold; color: #007bff; margin: 10px 0;">00:00:000</div>
    <div id="timer-status" style="font-size: 18px; margin-top: 5px;">In attesa dell'inizio del round</div>
</div>

    <h2>Giocatori</h2>
    <table id="players-table">
        <thead>
            <tr>
                <th>Giocatore</th>
                <th>Tempo Residuo</th>
                <th>Gettoni</th>
                <th>Stato</th>
            </tr>
        </thead>
        <tbody id="players-list">
            <!-- I giocatori verranno aggiunti qui dinamicamente -->
        </tbody>
    </table>

    <!-- Fase di Offerta -->
    <div class="bidding-status" style="margin-top: 20px; padding: 15px; background-color: #f0f0f0; border-radius: 8px; display: none;">
        <h3>Fase di Offerta in Corso</h3>
        <p>Tempo di offerta: <span id="bid-timer">0.00</span>s</p>
        <div id="active-bidders">
            <!-- Qui verranno mostrati i giocatori che stanno offrendo -->
        </div>
    </div>

    <div class="round-results">
        <h2>Risultati Round <span id="result-round-number">0</span></h2>
        <p style="font-size: 16px;">Durata del round: <span id="round-duration">00:00:000</span></p>
        <table id="round-results-table">
            <thead>
                <tr>
                    <th>Giocatore</th>
                    <th>Offerta</th>
                    <th>Risultato</th>
                </tr>
            </thead>
            <tbody id="round-results-list">
                <!-- I risultati verranno aggiunti qui dinamicamente -->
            </tbody>
        </table>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

    <script>
        let expectedPlayers = 2;
let isPlayerCountSet = false;
let bidTimerInterval = null;
let roundBidStartTime = 0;

// All'inizio della sezione <script>
let roundTimerInterval = null;
let roundStartTime = 0;
let isRoundTimerRunning = false;

// Funzione per formattare il tempo in MM:SS:MMM
function formatTime(timeInMs) {
    const minutes = Math.floor(timeInMs / 60000);
    const seconds = Math.floor((timeInMs % 60000) / 1000);
    const milliseconds = timeInMs % 1000;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
}

// Funzione per avviare il timer del round
function startRoundTimer() {
    if (roundTimerInterval) clearInterval(roundTimerInterval);
    roundStartTime = Date.now();
    isRoundTimerRunning = true;
    document.getElementById('timer-status').textContent = 'Round in corso';
    document.querySelector('.round-timer-container').classList.add('timer-active');
    roundTimerInterval = setInterval(function() {
        const elapsedTime = Date.now() - roundStartTime;
        document.getElementById('round-timer').textContent = formatTime(elapsedTime);
    }, 10);
}

// Funzione per fermare il timer del round
function stopRoundTimer() {
    if (roundTimerInterval) clearInterval(roundTimerInterval);
    roundTimerInterval = null;
    isRoundTimerRunning = false;
    document.getElementById('timer-status').textContent = 'Round terminato';
    document.querySelector('.round-timer-container').classList.remove('timer-active');
}

// Funzione per resettare il timer del round
function resetRoundTimer() {
    if (roundTimerInterval) clearInterval(roundTimerInterval);
    roundTimerInterval = null;
    isRoundTimerRunning = false;
    document.getElementById('round-timer').textContent = '00:00:000';
    document.getElementById('timer-status').textContent = 'In attesa dell\'inizio del round';
    document.querySelector('.round-timer-container').classList.remove('timer-active');
}

// Inserisci qui la configurazione di Firebase che hai copiato
const firebaseConfig = {
    // INCOLLA QUI LA TUA CONFIGURAZIONE FIREBASE
    apiKey: "AIzaSyD3kaXir_Hs53Cq4wID7Uz0z5fQxKYJutI",
  authDomain: "giocoastatempo.firebaseapp.com",
  databaseURL: "https://giocoastatempo-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "giocoastatempo",
  storageBucket: "giocoastatempo.firebasestorage.app",
  messagingSenderId: "1035401437404",
  appId: "1:1035401437404:web:b315574b573fb1997a5419"
};
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // Controlla se siamo autorizzati come host
        if (localStorage.getItem('playerType') !== 'host') {
            alert('Accesso non autorizzato al tabellone.');
            window.location.href = 'index.html';
        }

        const gameId = localStorage.getItem('gameId');
        if (!gameId) {
            alert('Nessuna partita trovata. Torna alla home.');
            window.location.href = 'index.html';
        }

        // Riferimento alla partita nel database
        const gameRef = database.ref('games/' + gameId);
        
        // Mostra il codice partita
        document.getElementById('game-id-display').textContent = 'Codice: ' + gameId;

        // Ascolta le modifiche alla partita
        gameRef.on('value', snapshot => {
            const game = snapshot.val();
            if (!game) {
                alert('Partita non trovata.');
                window.location.href = 'index.html';
                return;
            }

            // Aggiorna le informazioni di gioco
            document.getElementById('current-round').textContent = game.currentRound;
            
            // Aggiorna lo stato del gioco
            let statusText = 'Sconosciuto';
            switch(game.gameStatus) {
                case 'waiting':
                    statusText = 'In attesa di giocatori';
                    break;
                case 'running':
                    statusText = 'In corso';
                    break;
                case 'bidding':
                    statusText = 'Round in corso - Offerte';
                    break;
                case 'results':
                    statusText = 'Visualizzazione risultati';
                    break;
                case 'completed':
                    statusText = 'Partita terminata';
                    break;
            }
            document.getElementById('game-status').textContent = statusText;

            // Aggiorna l'elenco dei giocatori
            const playersList = document.getElementById('players-list');
            playersList.innerHTML = '';

            if (game.players) {
                Object.values(game.players).forEach(player => {
                    const row = document.createElement('tr');
                    if (player.isEliminated) {
                        row.classList.add('eliminated');
                    }

                    const nameCell = document.createElement('td');
                    nameCell.textContent = player.name;
                    
                    const timeCell = document.createElement('td');
                    const minutes = Math.floor(player.remainingTime / 60);
                    const seconds = player.remainingTime % 60;
                    timeCell.textContent = player.isEliminated ? 'ELIMINATO' : 
                        `${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
                    
                    const tokensCell = document.createElement('td');
                    tokensCell.textContent = player.tokens;
                    
                    const statusCell = document.createElement('td');
                    statusCell.textContent = player.isEliminated ? 'Eliminato' : 
                        (player.isReady ? 'Pronto' : 'In attesa');

                    row.appendChild(nameCell);
                    row.appendChild(timeCell);
                    row.appendChild(tokensCell);
                    row.appendChild(statusCell);
                    
                    playersList.appendChild(row);
                });
            }

            // Aggiorna i risultati del round corrente o precedente
            if (game.rounds && game.currentRound > 0) {
                const currentRoundData = game.rounds[game.currentRound];
                
                if (currentRoundData && currentRoundData.status === 'completed') {
                    document.getElementById('result-round-number').textContent = game.currentRound;
                    
                    // Visualizza la durata del round
                    if (currentRoundData.duration) {
                        document.getElementById('round-duration').textContent = formatTime(currentRoundData.duration);
                    }

                    const resultsList = document.getElementById('round-results-list');
                    resultsList.innerHTML = '';

                    if (game.players && currentRoundData.bids) {
                        // Converti i bid in una struttura più facilmente ordinabile
                        const bidsArray = [];
                        
                        Object.keys(currentRoundData.bids).forEach(playerId => {
                            if (game.players[playerId]) {
                                bidsArray.push({
                                    playerId: playerId,
                                    playerName: game.players[playerId].name,
                                    bidTime: currentRoundData.bids[playerId],
                                    isWinner: currentRoundData.winner === playerId
                                });
                            }
                        });

                        // Ordina per tempo offerto (discendente)
                        bidsArray.sort((a, b) => b.bidTime - a.bidTime);

                        // Crea le righe della tabella dei risultati
                        bidsArray.forEach(bid => {
                            const row = document.createElement('tr');
                            if (bid.isWinner) {
                                row.classList.add('winner');
                            }

                            const nameCell = document.createElement('td');
                            nameCell.textContent = bid.playerName;
                            
                            const bidCell = document.createElement('td');
                            const seconds = Math.floor(bid.bidTime);
                            const milliseconds = Math.floor((bid.bidTime - seconds) * 1000);
                            bidCell.textContent = `${seconds}.${milliseconds.toString().padStart(3, '0')}s`;
                            
                            const resultCell = document.createElement('td');
                            resultCell.textContent = bid.isWinner ? 'VINCITORE' : '';
                            
                            row.appendChild(nameCell);
                            row.appendChild(bidCell);
                            row.appendChild(resultCell);
                            
                            resultsList.appendChild(row);
                        });

                        // Se c'è stato un pareggio
                        if (currentRoundData.isTie) {
                            const tieRow = document.createElement('tr');
                            const tieCell = document.createElement('td');
                            tieCell.colSpan = 3;
                            tieCell.textContent = 'PAREGGIO - Nessun gettone assegnato';
                            tieCell.style.textAlign = 'center';
                            tieCell.style.fontWeight = 'bold';
                            tieCell.style.color = 'red';
                            tieRow.appendChild(tieCell);
                            resultsList.appendChild(tieRow);
                        }
                    }
                }
            }

            // Gestisci lo stato dei pulsanti e l'aspetto
            const startGameBtn = document.getElementById('start-game-btn');
            const nextRoundBtn = document.getElementById('next-round-btn');
            const connectedPlayersElement = document.getElementById('connected-players');

if (game.gameStatus === 'waiting') {
    const playerCount = Object.keys(game.players || {}).length;
    connectedPlayersElement.textContent = playerCount;

    // Abilita il pulsante di inizio solo se tutti i giocatori attesi sono connessi
    startGameBtn.disabled = !isPlayerCountSet || playerCount < expectedPlayers;
    nextRoundBtn.disabled = true;

    // Assicurati che il pulsante abbia l'aspetto corretto per "Inizia Partita"
    startGameBtn.textContent = 'Inizia Partita';
    startGameBtn.className = 'button';

    // Se il numero di giocatori attesi è già impostato nel database, aggiornalo nell'interfaccia
    if (game.expectedPlayers && !isPlayerCountSet) {
        expectedPlayers = game.expectedPlayers;
        document.getElementById('expected-players').value = expectedPlayers;
        document.getElementById('expected-players-count').textContent = expectedPlayers;
        document.getElementById('expected-players').disabled = true;
        document.getElementById('set-players-btn').disabled = true;
        isPlayerCountSet = true;
    }
} else if (game.gameStatus === 'running' || game.gameStatus === 'bidding' || game.gameStatus === 'results') {
    // Cambia l'aspetto e la funzione del pulsante a "Concludi il gioco"
    startGameBtn.textContent = 'Concludi il gioco';
    startGameBtn.className = 'end-game-btn';
    startGameBtn.disabled = false;

    nextRoundBtn.disabled = game.gameStatus === 'bidding';
} else if (game.gameStatus === 'completed') {
    startGameBtn.disabled = true;
    nextRoundBtn.disabled = true;
}

            // Aggiorna il numero di giocatori connessi
            const connectedPlayersCount = Object.keys(game.players || {}).length;
            document.getElementById('connected-players').textContent = connectedPlayersCount;
            document.getElementById('expected-players-count').textContent = game.expectedPlayers || 2;

            // Gestisci la visualizzazione dello stato di offerta
            const biddingStatusElement = document.querySelector('.bidding-status');

if (game.gameStatus === 'bidding' && game.rounds && game.rounds[game.currentRound]) {
    const currentRoundData = game.rounds[game.currentRound];

    // Se c'è almeno un giocatore che sta offrendo
    if (currentRoundData.bidding) {
        let anyoneBidding = false;
        const activeBiddersElement = document.getElementById('active-bidders');
        activeBiddersElement.innerHTML = '';

        Object.keys(currentRoundData.bidding).forEach(pid => {
            if (currentRoundData.bidding[pid] === true && game.players[pid]) {
                anyoneBidding = true;

                // Mostra chi sta offrendo
                const bidderElement = document.createElement('div');
                bidderElement.textContent = game.players[pid].name + ' sta offrendo';
                bidderElement.style.color = '#4CAF50';
                bidderElement.style.fontWeight = 'bold';
                bidderElement.style.margin = '5px 0';
                activeBiddersElement.appendChild(bidderElement);

                // Se è il primo, avvia il timer
                if (!bidTimerInterval) {
                    roundBidStartTime = Date.now();
                    bidTimerInterval = setInterval(function() {
                        const elapsedTime = (Date.now() - roundBidStartTime) / 1000;
                        document.getElementById('bid-timer').textContent = elapsedTime.toFixed(2);
                    }, 10);
                }
            }
        });

        // Mostra o nascondi lo stato di offerta
        biddingStatusElement.style.display = anyoneBidding ? 'block' : 'none';

        // Se nessuno sta offrendo ma c'è un ultimo offerente, concludi il round
        if (!anyoneBidding && currentRoundData.lastBidder && roundStartTime > 0) {
            clearInterval(bidTimerInterval);
            bidTimerInterval = null;

            // Calcola e salva la durata del round
            const roundDuration = Date.now() - roundStartTime;

            // Assegna il gettone all'ultimo giocatore che ha rilasciato
            const winnerId = currentRoundData.lastBidder;

            // Aggiorna lo stato del round
            gameRef.child(`rounds/${game.currentRound}`).update({
                status: 'completed',
                winner: winnerId,
                isTie: false,
                duration: roundDuration // Salva la durata del round
            });

            // Aggiorna il contatore di gettoni del vincitore
            const currentTokens = game.players[winnerId].tokens || 0;
            gameRef.child(`players/${winnerId}/tokens`).set(currentTokens + 1);

            // Cambia lo stato del gioco
            gameRef.update({
                gameStatus: 'results'
            });
        }
    } else {
        biddingStatusElement.style.display = 'none';

        // Resetta il timer se non c'è nessuno che sta offrendo
        if (bidTimerInterval) {
            clearInterval(bidTimerInterval);
            bidTimerInterval = null;
            roundBidStartTime = 0;
        }
    }
} else {
    biddingStatusElement.style.display = 'none';

    // Resetta il timer se non siamo in fase di offerta
    if (bidTimerInterval) {
        clearInterval(bidTimerInterval);
        bidTimerInterval = null;
        roundBidStartTime = 0;
    }
}

// Gestione del timer di round in base allo stato del gioco
if (game.gameStatus === 'bidding') {
    const currentRoundData = game.rounds && game.rounds[game.currentRound];
    const anyoneBidding = currentRoundData && currentRoundData.bidding &&
        Object.values(currentRoundData.bidding).some(status => status === true);

    if (anyoneBidding && !isRoundTimerRunning) {
        startRoundTimer();
    } else if (!anyoneBidding && isRoundTimerRunning) {
        stopRoundTimer();
    }
} else if (game.gameStatus === 'results') {
    if (isRoundTimerRunning) {
        stopRoundTimer();
    }
} else if (game.gameStatus === 'waiting' || game.gameStatus === 'running') {
    resetRoundTimer();
}
        });

        // Pulsante per iniziare la partita
        document.getElementById('start-game-btn').addEventListener('click', function() {
            gameRef.once('value').then(snapshot => {
                const game = snapshot.val();

                // Se la partita è in attesa, avviala direttamente in modalità bidding
                if (game && game.gameStatus === 'waiting') {
                    if (Object.keys(game.players || {}).length < 2) {
                        alert('Sono necessari almeno 2 giocatori per iniziare la partita.');
                        return;
                    }

                    // Aggiorna lo stato del gioco per avviarlo direttamente in modalità bidding
                    gameRef.update({
                        gameStatus: 'bidding', // Cambiato da 'running' a 'bidding'
                        currentRound: 1,
                        rounds: {
                            1: {
                                status: 'bidding', // Cambiato da 'waiting' a 'bidding'
                                bids: {},
                                bidding: {},
                                participating: {},
                                winner: null,
                                lastBidder: null,
                                isTie: false
                            }
                        }
                    });
                }
                // Se la partita è in corso, chiedi conferma per terminarla
                else if (game && (game.gameStatus === 'running' || game.gameStatus === 'bidding' || game.gameStatus === 'results')) {
                    if (confirm('Sei sicuro di voler concludere il gioco? Questa azione determinerà il vincitore in base ai gettoni attuali e terminerà la partita.')) {
                        // Chiama la funzione per determinare il vincitore
                        determineWinner(game);
                    }
                }
            });
        });

        // Pulsante per il prossimo round
        document.getElementById('next-round-btn').addEventListener('click', function() {
            gameRef.once('value').then(snapshot => {
                const game = snapshot.val();

                if (!game || (game.gameStatus !== 'running' && game.gameStatus !== 'results')) {
                    return;
                }

                // Se siamo all'ultimo round, termina la partita
                if (game.currentRound >= game.totalRounds) {
                    determineWinner(game);
                    return;
                }

                // Altrimenti, prepara il prossimo round
                const nextRound = game.currentRound + 1;

                // Prepara l'oggetto aggiornamento
                const updates = {
                    currentRound: nextRound,
                    gameStatus: 'bidding'
                };

                // Crea la struttura per il nuovo round
                updates[`rounds/${nextRound}`] = {
                    status: 'bidding',
                    bids: {},
                    bidding: {},
                    participating: {},
                    winner: null,
                    lastBidder: null,
                    isTie: false
                };

                // Resetta lo stato "isReady" di tutti i giocatori che non sono eliminati
                if (game.players) {
                    Object.keys(game.players).forEach(playerId => {
                        if (!game.players[playerId].isEliminated) {
                            updates[`players/${playerId}/isReady`] = false;
                        }
                    });
                }

                // Aggiorna il database
                gameRef.update(updates);
            });
            resetRoundTimer();
        });

        // Funzione per determinare il vincitore della partita
        function determineWinner(game) {
            // Trova il giocatore con più gettoni
            let maxTokens = -1;
            let winnersIds = [];
            
            Object.keys(game.players).forEach(playerId => {
                const player = game.players[playerId];
                if (player.tokens > maxTokens) {
                    maxTokens = player.tokens;
                    winnersIds = [playerId];
                } else if (player.tokens === maxTokens) {
                    winnersIds.push(playerId);
                }
            });
            
            // Se c'è un solo vincitore
            if (winnersIds.length === 1) {
                gameRef.update({
                    gameStatus: 'completed',
                    winner: winnersIds[0]
                });
                alert(`Il vincitore è ${game.players[winnersIds[0]].name} con ${maxTokens} gettoni!`);
                return;
            }
            
            // In caso di parità, considera il tempo residuo
            let maxTime = -1;
            let finalWinnerId = null;
            
            winnersIds.forEach(playerId => {
                const player = game.players[playerId];
                if (player.remainingTime > maxTime) {
                    maxTime = player.remainingTime;
                    finalWinnerId = playerId;
                }
            });
            
            gameRef.update({
                gameStatus: 'completed',
                winner: finalWinnerId
            });
            
            alert(`Il vincitore è ${game.players[finalWinnerId].name} con ${maxTokens} gettoni e più tempo residuo!`);
        }

        // Imposta il numero di giocatori attesi
        document.getElementById('set-players-btn').addEventListener('click', function() {
            const playerCountInput = document.getElementById('expected-players');
            const newCount = parseInt(playerCountInput.value, 10);

            if (isNaN(newCount) || newCount < 2) {
                alert('Il numero di giocatori deve essere almeno 2.');
                return;
            }

            expectedPlayers = newCount;
            document.getElementById('expected-players-count').textContent = expectedPlayers;

            // Aggiorna il database con il numero di giocatori attesi
            gameRef.update({
                expectedPlayers: expectedPlayers
            });

            // Disabilita il campo e il pulsante dopo l'impostazione
            playerCountInput.disabled = true;
            document.getElementById('set-players-btn').disabled = true;
            isPlayerCountSet = true;

            alert(`Numero di giocatori impostato a ${expectedPlayers}. Condividi il codice partita per far unire i giocatori.`);
        });
    </script>
</body>
</html>